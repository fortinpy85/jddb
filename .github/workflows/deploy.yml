name: Deploy to Production

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: ghcr.io/${{ github.repository }}/backend
  FRONTEND_IMAGE: ghcr.io/${{ github.repository }}/frontend

jobs:
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=sha-${GITHUB_SHA::7}
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Building version: ${VERSION}"

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ env.BACKEND_IMAGE }}:${{ steps.meta.outputs.version }}
            ${{ env.BACKEND_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.FRONTEND_IMAGE }}:${{ steps.meta.outputs.version }}
            ${{ env.FRONTEND_IMAGE }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event.inputs.environment == 'staging' || (github.event_name == 'push' && contains(github.ref, 'refs/tags/'))
    environment:
      name: staging
      url: https://staging.jddb.gc.ca

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."

          # Example deployment using SSH and Docker Compose
          # ssh ${{ secrets.STAGING_HOST }} << 'EOF'
          #   cd /var/www/jddb-staging
          #   docker-compose pull
          #   docker-compose up -d --remove-orphans
          #   docker system prune -f
          # EOF

      - name: Run smoke tests
        run: |
          sleep 30  # Wait for deployment to complete

          # Run basic smoke tests
          STAGING_URL="https://staging.jddb.gc.ca"
          API_URL="https://api-staging.jddb.gc.ca"

          # Check frontend
          curl -f ${STAGING_URL} || exit 1

          # Check API health
          curl -f ${API_URL}/health || exit 1

          # Check critical endpoints
          curl -f ${API_URL}/api/jobs/status || exit 1

          echo "✅ Staging deployment smoke tests passed"

      - name: Run integration tests
        run: |
          # Run integration test suite against staging
          cd backend
          poetry install
          poetry run pytest tests/integration/ \
            --base-url=https://api-staging.jddb.gc.ca \
            -v

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: github.event.inputs.environment == 'production' || (github.event_name == 'push' && contains(github.ref, 'refs/tags/'))
    environment:
      name: production
      url: https://jddb.gc.ca

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create deployment backup
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          echo "Creating pre-deployment backup: ${TIMESTAMP}"

          # Backup current deployment state
          # ssh ${{ secrets.PRODUCTION_HOST }} << EOF
          #   cd /var/www/jddb
          #   docker-compose ps > deployment_state_${TIMESTAMP}.txt
          #   docker images | grep jddb > images_${TIMESTAMP}.txt
          # EOF

      - name: Blue-Green Deployment
        run: |
          echo "Starting blue-green deployment..."

          # Deploy to blue environment first
          # ssh ${{ secrets.PRODUCTION_HOST }} << 'EOF'
          #   cd /var/www/jddb-blue
          #   docker-compose pull
          #   docker-compose up -d --remove-orphans
          #
          #   # Health check blue environment
          #   sleep 30
          #   curl -f http://localhost:8001/health || exit 1
          #
          #   # Switch load balancer to blue
          #   nginx -s reload
          #
          #   # Stop green environment after successful switch
          #   cd /var/www/jddb-green
          #   docker-compose down
          # EOF

      - name: Verify deployment
        id: verify
        run: |
          sleep 60  # Wait for deployment to stabilize

          PROD_URL="https://jddb.gc.ca"
          API_URL="https://api.jddb.gc.ca"

          # Comprehensive health checks
          CHECKS_PASSED=0
          TOTAL_CHECKS=5

          # Check 1: Frontend availability
          if curl -f ${PROD_URL}; then
            ((CHECKS_PASSED++))
            echo "✅ Frontend is accessible"
          else
            echo "❌ Frontend is not accessible"
          fi

          # Check 2: API health endpoint
          if curl -f ${API_URL}/health; then
            ((CHECKS_PASSED++))
            echo "✅ API health check passed"
          else
            echo "❌ API health check failed"
          fi

          # Check 3: Database connectivity
          if curl -f ${API_URL}/api/jobs/status; then
            ((CHECKS_PASSED++))
            echo "✅ Database connectivity verified"
          else
            echo "❌ Database connectivity failed"
          fi

          # Check 4: WebSocket connectivity
          if curl -f ${API_URL}/ws/health; then
            ((CHECKS_PASSED++))
            echo "✅ WebSocket service is running"
          else
            echo "❌ WebSocket service is not responding"
          fi

          # Check 5: Redis connectivity
          if curl -f ${API_URL}/api/monitoring/cache-status; then
            ((CHECKS_PASSED++))
            echo "✅ Redis cache is operational"
          else
            echo "❌ Redis cache is not responding"
          fi

          echo "Health checks passed: ${CHECKS_PASSED}/${TOTAL_CHECKS}"

          if [ $CHECKS_PASSED -lt 3 ]; then
            echo "deployment_status=failed" >> $GITHUB_OUTPUT
            echo "❌ Deployment verification failed. Triggering rollback..."
            exit 1
          else
            echo "deployment_status=success" >> $GITHUB_OUTPUT
            echo "✅ All critical health checks passed"
          fi

      - name: Performance validation
        run: |
          # Run performance tests to ensure no regression
          cd tests/performance
          npm install
          npm run test:production -- \
            --threshold-response-time=500 \
            --threshold-error-rate=1

      - name: Update deployment record
        if: success()
        run: |
          VERSION="${{ needs.build-and-push.outputs.version }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          cat > deployment_record.json <<EOF
          {
            "version": "${VERSION}",
            "timestamp": "${TIMESTAMP}",
            "deployed_by": "${{ github.actor }}",
            "environment": "production",
            "status": "success",
            "health_checks": "passed"
          }
          EOF

          # Store deployment record
          # aws s3 cp deployment_record.json s3://jddb-deployments/${VERSION}.json

  trigger-rollback:
    name: Trigger Automatic Rollback
    runs-on: ubuntu-latest
    needs: deploy-production
    if: failure()

    steps:
      - name: Trigger rollback workflow
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'rollback.yml',
              ref: 'main',
              inputs: {
                environment: 'production',
                reason: 'Automatic rollback due to deployment failure'
              }
            });

            console.log('Rollback workflow triggered');

  notify:
    name: Notify Team
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()

    steps:
      - name: Send deployment notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ needs.deploy-production.result }}
          text: |
            Deployment ${{ needs.deploy-production.result == 'success' && 'completed successfully' || 'failed' }}
            Environment: ${{ github.event.inputs.environment || 'production' }}
            Version: ${{ github.ref }}
            Deployed by: ${{ github.actor }}
            ${{ needs.deploy-production.result != 'success' && 'Automatic rollback initiated' || '' }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create deployment summary
        env:
          DEPLOY_STATUS: ${{ needs.deploy-production.result == 'success' && '✅ Success' || '❌ Failed' }}
          VERSION: ${{ github.ref }}
          ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}
          ACTOR: ${{ github.actor }}
          FRONTEND_STATUS: ${{ needs.deploy-production.outputs.frontend_status || 'N/A' }}
          API_STATUS: ${{ needs.deploy-production.outputs.api_status || 'N/A' }}
          DB_STATUS: ${{ needs.deploy-production.outputs.db_status || 'N/A' }}
          WS_STATUS: ${{ needs.deploy-production.outputs.ws_status || 'N/A' }}
          REDIS_STATUS: ${{ needs.deploy-production.outputs.redis_status || 'N/A' }}
          FINAL_MESSAGE: ${{ needs.deploy-production.result != 'success' && '### ⚠️ Automatic rollback has been triggered' || '### ✅ Deployment completed successfully' }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # Deployment Summary

          ## Status: ${DEPLOY_STATUS}

          - **Version**: ${VERSION}
          - **Environment**: ${ENVIRONMENT}
          - **Deployed by**: @${ACTOR}
          - **Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")

          ### Health Check Results
          - Frontend: ${FRONTEND_STATUS}
          - API: ${API_STATUS}
          - Database: ${DB_STATUS}
          - WebSocket: ${WS_STATUS}
          - Redis: ${REDIS_STATUS}

          ${FINAL_MESSAGE}
          EOF
