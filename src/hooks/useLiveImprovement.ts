/**
 * useLiveImprovement Hook
 *
 * Real-time reactive improvement analysis with debouncing.
 * Automatically analyzes text as user types and provides live suggestions.
 */

import { useState, useCallback, useEffect, useRef } from "react";
import { useAISuggestions } from "./useAISuggestions";
import { analyzeDiff } from "@/utils/diffAnalysis";
import type { TextChange, DiffResult } from "@/utils/diffAnalysis";
import type { AISuggestion } from "./useAISuggestions";

export interface UseLiveImprovementOptions {
  debounceMs?: number;
  minLength?: number;
  autoAnalyze?: boolean;
  captureRLHF?: boolean;
  onImprovedTextGenerated?: (improvedText: string) => void;
  onAnalysisComplete?: (result: DiffResult) => void;
}

export interface UseLiveImprovementReturn {
  // Original text
  originalText: string;
  setOriginalText: (text: string) => void;

  // Improved text (generated by AI)
  improvedText: string;

  // Analysis state
  isAnalyzing: boolean;
  lastAnalyzedAt: Date | null;

  // Suggestions and changes
  suggestions: AISuggestion[];
  changes: TextChange[];
  diffResult: DiffResult | null;

  // Current suggestion being viewed
  currentSuggestion: AISuggestion | null;
  setCurrentSuggestion: (suggestion: AISuggestion | null) => void;

  // Quality metrics
  overallScore: number | null;

  // Actions
  triggerAnalysis: () => void;
  acceptSuggestion: (suggestion: AISuggestion) => void;
  rejectSuggestion: (suggestion: AISuggestion) => void;
  applyImprovement: () => string;

  // RLHF tracking
  rlhfEvents: RLHFEvent[];
  exportRLHFData: () => RLHFEvent[];
}

export interface RLHFEvent {
  timestamp: string;
  eventType: "accept" | "reject" | "modify" | "generate";
  suggestionId?: string;
  suggestionType?: string;
  originalText: string;
  suggestedText?: string;
  finalText?: string;
  userAction: string;
  confidence?: number;
  metadata?: Record<string, any>;
}

/**
 * Main useLiveImprovement hook
 */
export function useLiveImprovement({
  debounceMs = 2000,
  minLength = 50,
  autoAnalyze = true,
  captureRLHF = true,
  onImprovedTextGenerated,
  onAnalysisComplete,
}: UseLiveImprovementOptions = {}): UseLiveImprovementReturn {
  // State
  const [originalText, setOriginalTextState] = useState("");
  const [improvedText, setImprovedText] = useState("");
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [lastAnalyzedAt, setLastAnalyzedAt] = useState<Date | null>(null);
  const [diffResult, setDiffResult] = useState<DiffResult | null>(null);
  const [currentSuggestion, setCurrentSuggestion] =
    useState<AISuggestion | null>(null);
  const [rlhfEvents, setRlhfEvents] = useState<RLHFEvent[]>([]);

  // Refs
  const debounceTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const analysisCounterRef = useRef(0);

  // AI Suggestions hook
  const {
    suggestions,
    overallScore,
    isLoading: aiLoading,
    fetchSuggestions,
    acceptSuggestion: acceptAISuggestion,
    rejectSuggestion: rejectAISuggestion,
  } = useAISuggestions();

  // Set original text with debounced analysis
  const setOriginalText = useCallback(
    (text: string) => {
      setOriginalTextState(text);

      // Clear previous timer
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }

      // Don't analyze if text is too short
      if (text.length < minLength) {
        setIsAnalyzing(false);
        return;
      }

      // Auto-analyze if enabled
      if (autoAnalyze) {
        setIsAnalyzing(true);

        // Set new debounced timer
        debounceTimerRef.current = setTimeout(() => {
          triggerAnalysisInternal(text);
        }, debounceMs);
      }
    },
    [minLength, autoAnalyze, debounceMs],
  );

  // Trigger analysis manually or via debounce
  const triggerAnalysisInternal = useCallback(
    async (text: string) => {
      const analysisId = ++analysisCounterRef.current;

      try {
        setIsAnalyzing(true);

        // Fetch AI suggestions
        await fetchSuggestions(text, "job_description", [
          "grammar",
          "style",
          "clarity",
          "bias",
          "compliance",
        ]);

        // Generate improved text by applying suggestions
        // In real implementation, this would call a backend API
        const improved = await generateImprovedText(text, suggestions);

        // Only update if this is still the latest analysis
        if (analysisId === analysisCounterRef.current) {
          setImprovedText(improved);
          setLastAnalyzedAt(new Date());

          // Run diff analysis
          const result = analyzeDiff(text, improved, suggestions);
          setDiffResult(result);

          // Callbacks
          onImprovedTextGenerated?.(improved);
          onAnalysisComplete?.(result);

          // Capture RLHF event
          if (captureRLHF) {
            captureRLHFEvent({
              eventType: "generate",
              originalText: text,
              suggestedText: improved,
              userAction: "ai_generated",
              metadata: {
                suggestionCount: suggestions.length,
                overallScore,
                analysisId,
              },
            });
          }
        }
      } catch (error) {
        console.error("Live analysis failed:", error);
      } finally {
        if (analysisId === analysisCounterRef.current) {
          setIsAnalyzing(false);
        }
      }
    },
    [
      suggestions,
      onImprovedTextGenerated,
      onAnalysisComplete,
      captureRLHF,
      overallScore,
    ],
  );

  // Public trigger analysis method
  const triggerAnalysis = useCallback(() => {
    if (originalText.length >= minLength) {
      triggerAnalysisInternal(originalText);
    }
  }, [originalText, minLength, triggerAnalysisInternal]);

  // Accept suggestion
  const acceptSuggestion = useCallback(
    (suggestion: AISuggestion) => {
      // Apply the suggestion to improved text
      const newImprovedText = improvedText.replace(
        suggestion.original_text,
        suggestion.suggested_text,
      );
      setImprovedText(newImprovedText);

      // Update AI suggestions state
      acceptAISuggestion(suggestion.id);

      // Capture RLHF event
      if (captureRLHF) {
        captureRLHFEvent({
          eventType: "accept",
          suggestionId: suggestion.id,
          suggestionType: suggestion.type,
          originalText: suggestion.original_text,
          suggestedText: suggestion.suggested_text,
          finalText: suggestion.suggested_text,
          userAction: "accepted",
          confidence: suggestion.confidence,
        });
      }

      // Clear current suggestion
      setCurrentSuggestion(null);
    },
    [improvedText, acceptAISuggestion, captureRLHF],
  );

  // Reject suggestion
  const rejectSuggestion = useCallback(
    (suggestion: AISuggestion) => {
      // Update AI suggestions state
      rejectAISuggestion(suggestion.id);

      // Capture RLHF event
      if (captureRLHF) {
        captureRLHFEvent({
          eventType: "reject",
          suggestionId: suggestion.id,
          suggestionType: suggestion.type,
          originalText: suggestion.original_text,
          suggestedText: suggestion.suggested_text,
          finalText: suggestion.original_text, // User kept original
          userAction: "rejected",
          confidence: suggestion.confidence,
        });
      }

      // Clear current suggestion
      setCurrentSuggestion(null);
    },
    [rejectAISuggestion, captureRLHF],
  );

  // Apply all improvements and return final text
  const applyImprovement = useCallback(() => {
    return improvedText;
  }, [improvedText]);

  // Capture RLHF event
  const captureRLHFEvent = useCallback(
    (event: Omit<RLHFEvent, "timestamp">) => {
      const fullEvent: RLHFEvent = {
        ...event,
        timestamp: new Date().toISOString(),
      };

      setRlhfEvents((prev) => [...prev, fullEvent]);

      // Also save to localStorage for persistence
      try {
        const existingData = JSON.parse(
          localStorage.getItem("rlhf_live_events") || "[]",
        );
        existingData.push(fullEvent);
        localStorage.setItem("rlhf_live_events", JSON.stringify(existingData));

        // Auto-sync when threshold reached (10 events)
        if (existingData.length >= 10) {
          syncRLHFData().catch((error) => {
            console.error(`Auto-sync failed:`, error);
          });
        }
      } catch (error) {
        console.error("Failed to save RLHF event to localStorage:", error);
      }
    },
    [],
  );

  // Export RLHF data
  const exportRLHFData = useCallback(() => {
    return rlhfEvents;
  }, [rlhfEvents]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, []);

  return {
    // Original text
    originalText,
    setOriginalText,

    // Improved text
    improvedText,

    // Analysis state
    isAnalyzing: isAnalyzing || aiLoading,
    lastAnalyzedAt,

    // Suggestions and changes
    suggestions,
    changes: diffResult?.changes || [],
    diffResult,

    // Current suggestion
    currentSuggestion,
    setCurrentSuggestion,

    // Quality metrics
    overallScore,

    // Actions
    triggerAnalysis,
    acceptSuggestion,
    rejectSuggestion,
    applyImprovement,

    // RLHF tracking
    rlhfEvents,
    exportRLHFData,
  };
}

/**
 * Generate improved text by applying AI suggestions
 * In production, this would call a backend API
 */
async function generateImprovedText(
  originalText: string,
  suggestions: AISuggestion[],
): Promise<string> {
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 500));

  let improved = originalText;

  // Apply high-confidence suggestions automatically
  suggestions
    .filter((s) => s.confidence >= 0.8)
    .forEach((suggestion) => {
      improved = improved.replace(
        suggestion.original_text,
        suggestion.suggested_text,
      );
    });

  // Basic improvements
  improved = improved
    .replace(/he\/she/gi, "they")
    .replace(/his\/her/gi, "their")
    .replace(/\s+/g, " ")
    .trim();

  return improved;
}

/**
 * Export all RLHF data from localStorage
 */
export function exportAllRLHFData(): RLHFEvent[] {
  try {
    return JSON.parse(localStorage.getItem("rlhf_live_events") || "[]");
  } catch (error) {
    console.error("Failed to export RLHF data:", error);
    return [];
  }
}

/**
 * Clear all RLHF data
 */
export function clearAllRLHFData(): void {
  try {
    localStorage.removeItem("rlhf_live_events");
  } catch (error) {
    console.error("Failed to clear RLHF data:", error);
  }
}

/**
 * Sync RLHF events to backend and clear localStorage
 */
export async function syncRLHFData(): Promise<{
  success: boolean;
  synced: number;
  error?: string;
}> {
  try {
    const events = exportAllRLHFData();

    if (events.length === 0) {
      return { success: true, synced: 0 };
    }

    // Import API client dynamically to avoid circular dependencies
    const { apiClient } = await import("@/lib/api");

    const result = await apiClient.syncRLHFEvents(events);

    // Clear localStorage after successful sync
    clearAllRLHFData();

    return { success: true, synced: events.length };
  } catch (error) {
    console.error("Failed to sync RLHF data:", error);
    return {
      success: false,
      synced: 0,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}

/**
 * Get count of pending RLHF events
 */
export function getPendingRLHFCount(): number {
  try {
    const events = exportAllRLHFData();
    return events.length;
  } catch (error) {
    console.error("Failed to get pending RLHF count:", error);
    return 0;
  }
}
